{"name":"Binjitsu: Google Summer Of Code","tagline":"CTF framework and exploit development library","body":"![](gsoc.png)\r\n\r\n# Pwntools & Binjitsu: Google Summer of Code\r\n\r\nWelcome to the Google Summer of Code landing page for the Pwntools and Binjitsu projects!\r\n\r\nYou can find more information about the project, its mentors, project ideas, and how to get started below!\r\n\r\n- [About Pwntools](#about-pwntools-and-binjitsu)\r\n- [Mentors and Contact Information](#mentors)\r\n- [Project Ideas](#project-ideas)\r\n- [Getting Started](#getting-started)\r\n\r\n## About Pwntools and Binjitsu\r\n\r\n### What are binjitsu and pwntools?\r\n\r\n`pwntools` is an open-source, MIT-licensed framework for automating and aiding in the development of exploits for Capture The Flag computer security competitions.  `binjitsu` is a fork of this project that is developed more rapidly, which contributes changes back to the main `pwntools` project.\r\n\r\nIn particular, `pwntools` provides commonly-used functionality which are frequently re-implemented by exploit authors for each exploit, or copy-pasted around.  Additionally, it provides assistance in the exploit development process by automating some operations, or providing automated analysis and discovery about a program.\r\n\r\n**If you're unfamiliar with Capture the Flag and Competitive Hacking, you should watch [this video!](https://www.youtube.com/watch?v=ECMExVt1lbI).**\r\n\r\n### Why is it interesting?\r\n\r\nHollywood glamorizes hacking and hackers, but the truth is that computer security, vulnerability research, and exploit development are much more tedious than what's shown on the silver screen.  While we'll never reach a place where we have [crazy 3D cube exploit auto-generators][3], we can certainly strive to make each part easier, faster, and more enjoyable.\r\n\r\n[3]: https://www.youtube.com/watch?v=cmR3wIBJZbk\r\n\r\n### Who uses it?\r\n\r\n`pwntools` is widely used throughout the Capture the Flag and Wargames community.  It's primarily developed by the Gallopsled CTF team, which use it exclusively.  Its has spread among the community because of its ease of use and utility.\r\n\r\nOne of the common post-competition activities for CTF is to post a write-up of the challenge binary.  Generally, this includes an analysis of the binary, its vulnerabilities, and details on the exploitation process.  Searching Google for `\"from pwn import\"` yields about 1300 hits, almost all of which are unique write-ups from different authors.\r\n\r\n### What language is it written in?\r\n\r\n`pwntools` is written exclusively in Python, and targets Python 2.7.\r\n\r\n### How is it going to change the world?\r\n\r\n`pwntools` is already an excellent resource for experienced competitors, but ideally would also be a teaching resource.  Many of the pitfalls that are encountered when starting out with reverse engineering and exploit development are side-stepped by using `pwntools`, because it was written with knowledge of those pitfalls.\r\n\r\nBy making computer security and exploitation more approachable, we can enhance general awareness about common security-related mistakes which lead to memory corruption and eventually code execution.\r\n\r\n## Mentors\r\n\r\nThis is the current list of mentors for any Google Summer of Code projects.\r\n\r\n### [Zach Riggle (ebeip90)](https://github.com/ZachRiggle)\r\n\r\nMaintainer and developer of the `binjitsu` fork, contributor to `pwntools`.\r\n\r\n### [Mathias Svensson (Idolf)](https://github.com/Idolf)\r\n\r\nMaintainer and developer of `pwntools`.\r\n\r\n### [Morten Br√∏ns-Pedersen (br0ns)](https://github.com/br0ns)\r\n\r\nMaintainer and developer of `pwntools`.\r\n\r\n## Getting in Touch\r\n\r\nThe best way to get ahold of us is on IRC! Feel free to join and introduce yourself, or ask any questions you may have!\r\n\r\n\r\n- IRC channel: `#pwning` on Freenode\r\n- Nicks: `ebeip90`, `IdolfHatler`, `br0ns`\r\n\r\n\r\n## Getting Started\r\n\r\nPwntools is designed to get you up and running as fast as possible!\r\n\r\n### Getting the Software\r\n\r\nGetting started with Binjitsu is easy!  If you're using Ubuntu, only a few commands away.\r\n\r\n```\r\n$ apt-get install python2.7 python2.7-dev python-pip\r\n$ git clone https://github.com/binjitsu/binjitsu\r\n$ cd binjitsu\r\n$ pip install -e .\r\n```\r\n\r\n### First Steps and Examples\r\n\r\nThe online documentation has a [Getting Started](http://binjitsu.readthedocs.org/en/latest/intro.html) section for demonstrating some of the basic features.  More advanced use cases be found in the [write-ups](https://github.com/Gallopsled/pwntools-write-ups) repository, or [just by searching Google for `from pwn import *`](https://www.google.com/webhp#q=%22from+pwn+import%22)!\r\n\r\n### Contributing and Source Control\r\n\r\nBoth `pwntools` and `binjitsu` use [Github](https://github.com) for source control and [Travis CI](https://travis-ci.com) for automatic testing.\r\n\r\nInstructions on getting up and running with a local copy for development are available in [CONTRIBUTING.md](https://github.com/binjitsu/binjitsu/blob/master/CONTRIBUTING.md) for each project.\r\n\r\n## Project Ideas\r\n\r\nThis is the current list of ideas, sorted in general order of \"easiest\" to \"hardest\".\r\n\r\n##### Python-Only Enhancements\r\n\r\nThese ideas only require knowledge of Python, and do not expect experience regarding binary exploitation or Capture the Flag.\r\n\r\n- [Unit Testing](#unit)\r\n- [Integration Testing](#integration)\r\n- [ELF Modification](#elf)\r\n- [OS X Compatibility](#mac)\r\n- [Windows PE Support](#pe)\r\n- [Terminal Revamp](#term)\r\n\r\n##### Exploitation Improvements\r\n\r\nThese improvements require both knowledge of Python, and a good understanding of reverse engineering and exploitation primitives.\r\n\r\n- [Moar Exploits!](#exploits)\r\n- [Moar Shellcode!](#shellcode)\r\n- [SIGRET Assistance](#sigret)\r\n- [Format Strings](#format)\r\n- [Shellcode Encoders](#encoders)\r\n- [Multi-Architecture ROP](#ROP)\r\n\r\n### <a name=\"unit\"></a>Port Doctests to a Unit Testing Framework\r\n\r\nCurrently, all of the tests are run as part of a wrapper via `sphinx`.  This places a large number of restrictions on the tests, and requires manual addition to the corpus rather than automated test enumeration.  Ideally, test discovery would be automated, and handle both doctests and unit tests.  Both `nosetests` and `py.test` are excellent candidates for this, but there are expectations built into the current tests which preclude the use of these frameworks.\r\n\r\n#### Skills Required\r\n\r\n- Python\r\n- Linux\r\n\r\n#### Resources\r\n\r\n- [Testing Your Code - Hitchhiker's Guide to Python](http://docs.python-guide.org/en/latest/writing/tests/)\r\n- [PyTest.org](http://pytest.org/latest/)\r\n- [Continuous Integration in Python: Travis-CI](http://ilovesymposia.com/2014/10/15/continuous-integration-in-python-4-set-up-travis-ci/)\r\n\r\n#### Difficulty Level\r\n\r\nLow\r\n\r\n#### Potential Mentors\r\n\r\n- `ebeip90`\r\n- `Idolf`\r\n- `br0ns`\r\n\r\n\r\n### <a name=\"integration\"></a>Extend Integration Testing Framework and Examples\r\n\r\nThere is also a [regression testing][2] framework that's designed to permit automatic testing of various parts of pwntools as a whole, rather than in bite-sized prepared chunks.  This regression testing code works, but it is not complete and does not give good coverage for all of the code.\r\n\r\nThe current [examples repository][1] is a bit outdated and doesn't work with the current incarnation of pwntools or binjitsu.  Unfortunately, new users have very little options to turn to when looking for a good starting point for \"How do I pwntools\".\r\n\r\n[1]: https://github.com/Gallopsled/pwntools-write-ups\r\n[2]: https://github.com/Gallopsled/pwntools-regression\r\n\r\n#### Skills Required\r\n\r\n- C\r\n- Python\r\n- Linux\r\n\r\n#### Resources\r\n\r\n- [Integration Testing (Wikipedia)](http://en.wikipedia.org/wiki/Integration_testing)\r\n\r\n#### Difficulty Level\r\n\r\nLow to medium\r\n\r\n#### Potential Mentors\r\n\r\n- `ebeip90`\r\n- `Idolf`\r\n- `br0ns`\r\n\r\n### <a name=\"elf\"></a>Enhancements to `pwnlib.elf` module for editing ELFs\r\n\r\nCurrently, the `pwnlib.elf` module has primitives to allow modifying arbitrary sections of the on-disk image of a loaded ELF file.  However, the limitations of the `pyelftools` library used to perform these operations prevents adding entire sections to the ELF binary, or adding relocations to it.\r\n\r\nExtending the existing functionality to provide the ability to modify, re-order, or otherwise re-write ELF files without affecting their native functionality (a la `the-backdoor-factory`) would be a great benefit to attack-defend CTFs.\r\n\r\n#### Skills Required\r\n\r\n- Python\r\n- Linux\r\n\r\n#### Resources\r\n\r\n- [Executable and Linkable Format (Wikipedia)](http://en.wikipedia.org/wiki/Executable_and_Linkable_Format)\r\n- [the-backdoor-factory](https://github.com/secretsquirrel/the-backdoor-factory)\r\n\r\n#### Difficulty Level\r\n\r\nMedium\r\n\r\n#### Potential Mentors\r\n\r\n- `ebeip90`\r\n- `Idolf`\r\n- `br0ns`\r\n\r\n### <a name=\"mac\"></a>Mac OS X Support\r\n\r\nCurrently, `pwntools` and `binjitsu` work best on Linux distributions like Ubuntu.  \r\nHowever, lots of developers prefer to use alternate operating systems like Mac OS X,\r\nand some future challenges may even be written for it.\r\n\r\nThis project would require making changes to `binjitsu` to make as many unit tests\r\nas possible pass on Mac OS X, integrating these with Travis CI, and perhaps even\r\nwriting some integration tests to ensure end-to-end functionality.\r\n\r\nA stretch goal would be to extend the current generation and parsing of ELF files\r\nto include the Mach-O format used by OS X.\r\n\r\n#### Skills Required\r\n\r\n- Python\r\n- Linux\r\n- OS X\r\n\r\n#### Resources\r\n\r\n- [Porting UNIX/Linux Applications to OS X](https://developer.apple.com/library/mac/documentation/Porting/Conceptual/PortingUnix/intro/intro.htm)\r\n- [Mach-O (Wikipedia)](http://en.wikipedia.org/wiki/Mach-O)\r\n\r\n#### Difficulty Level\r\n\r\nMedium\r\n\r\n#### Potential Mentors\r\n\r\n- `ebeip90`\r\n\r\n### <a name=\"pe\"></a>Windows PE File Support\r\n\r\nCurrently, `pwntools` and `binjitsu` have a lot of helper utilities for loading,\r\nparsing, and extracting information from Linux ELF files.  However, the same \r\nlevel of support is not present for Windows PE files.\r\n\r\nThe goal of this project would be to create a compatibility layer between the\r\ncurrent ELF functionality based on `pyelftools`, and the Python PE library, `pefile`.\r\n\r\n#### Skills Required\r\n\r\n- Python\r\n- Linux\r\n- Windows\r\n\r\n#### Resources\r\n\r\n- [PEFile](https://code.google.com/p/pefile/)\r\n- [PyElfTools](https://github.com/eliben/pyelftools)\r\n- [PE 101](http://corkami.googlecode.com/files/PE101-v1.pdf)\r\n- [ELF 101](https://corkami.googlecode.com/files/elf101.pdf)\r\n\r\n#### Difficulty Level\r\n\r\nMedium\r\n\r\n#### Potential Mentors\r\n\r\n- `ebeip90`\r\n- `Idolf`\r\n- `br0ns`\r\n\r\n### <a name=\"term\"></a>Overhaul / re-write of the `pwnlib.term` module\r\n\r\nThis module is currently the least-well-understood module and in its current form isn't documented or tested.\r\n\r\nRe-implementing, or re-factoring the current implementation, should allow this module to be tested in an automated manner.\r\n\r\n#### Skills Required\r\n\r\n- Python\r\n- Linux\r\n\r\n#### Resources\r\n\r\n- [Terminal Emulation (Wikipedia)](http://en.wikipedia.org/wiki/Terminal_emulator)\r\n- [Curses (Python Library)](https://docs.python.org/2/library/curses.html)\r\n\r\n#### Difficulty Level\r\n\r\nLow to medium\r\n\r\n#### Potential Mentors\r\n\r\n- `ebeip90`\r\n- `Idolf`\r\n- `br0ns`\r\n\r\n## <a name=\"exploits\"></a>More Exploit Examples!\r\n\r\nThere are easily hundreds of different exploits available [just from searching Google](https://www.google.com/webhp#q=%22from+pwn+import%22).\r\nUnfortunately, these aren't all in one central location, and aren't being used to verify\r\nthat we're aware of any feature-breaking changes that we make.\r\n\r\nThis project would involve finding well-written exploits using `pwntools` \r\n(or re-writing other exploits to use it) and collecting them into the \r\n`pwntools-write-ups` repository.\r\n\r\nAfter a good number are gathered and in working condition, a wrapper should\r\nbe developed to ensure that the exploits all work with a single command, so\r\nthat this can be integrated into the Continuous Integration tests.\r\n\r\n#### Skills Required\r\n\r\n- Python\r\n- Linux\r\n- Willing to learn!\r\n\r\n#### Resources\r\n\r\n- [pwntools-write-ups](https://github.com/Gallopsled/pwntools-write-ups)\r\n- [Google: \"from pwn import *\"](https://www.google.com/webhp#q=%22from+pwn+import%22)\r\n\r\n#### Difficulty Level\r\n\r\nVaries wildly, from low to very high\r\n\r\n#### Potential Mentors\r\n\r\n- `ebeip90`\r\n- `Idolf`\r\n- `br0ns`\r\n\r\n### <a name=\"shellcode\"></a>Porting Shellcode to Pwntools\r\n\r\nPwntools currently has a good deal of shellcode available in `pwnlib.shellcraft` for i386, amd64, and ARM.  However, there are lots of things that are missing (e.g. file-read, file-write, file descriptor proxying) which would be excellent additions to the corpus.\r\n\r\nPorting shellcode to pwntools would require ingesting shellcode from Shell-Storm.org or ExploitDB.com, and re-writing them as Mako templates in pwntools.  Ideally, all shellcode will use (or be refactored to use) templates for common operations.\r\n\r\n#### Skills Required\r\n\r\n- Python\r\n- Assembly\r\n- Linux\r\n\r\n#### Resources\r\n\r\n- [Shell-Storm Shellcode Database](http://shell-storm.org/shellcode/)\r\n- [ExploitDB Shellcode Database](http://www.exploit-db.com/shellcode/)\r\n\r\n#### Difficulty Level\r\n\r\nLow to Moderate\r\n\r\n#### Potential Mentors\r\n\r\n- `ebeip90`\r\n- `Idolf`\r\n- `br0ns`\r\n\r\n### <a name=\"sigret\"></a>SIGRET Exploitation Assitance\r\n\r\nCurrently, `pwntools` is completely unaware of SIGRET-style ROP (SROP).  Helpers for generating valid register frames for use with SROP would be very useful.\r\n\r\n#### Skills Required\r\n\r\n- Python\r\n- Linux\r\n- Familiar with ROP\r\n\r\n#### Resources\r\n\r\n- [Framing Signals - A Return to Portable Shellcode](https://www.cs.vu.nl/~herbertb/papers/srop_sp14.pdf)\r\n- [Playing around with SROP](http://x86overflow.blogspot.com/2014/04/playing-around-with-srop.html)\r\n- [An overview on Sigreturn Oriented Programming](http://thisissecurity.net/2015/01/03/playing-with-signals-an-overview-on-sigreturn-oriented-programming/)\r\n\r\n#### Difficulty Level\r\n\r\nMedium\r\n\r\n#### Potential Mentors\r\n\r\n- `ebeip90`\r\n- `Idolf`\r\n- `br0ns`\r\n\r\n### <a name=\"format\"></a>Format String Payload Generation\r\n\r\nCurrently, `pwntools` is unable to offer any assistance in generation of format string payloads.  The open-source project `libformatstr` would serve as an excellent starting point for adding this functionality to pwntools.\r\n\r\nAdditional functionality could be added in order to enhance the robustness and automation.  For example, the `DynELF` object in `pwntools` allows automatically leaking memory to resolve symbols in remote address spaces.  A similar mechanism could be used to automate discovery of control bounds (e.g. format string input size, argument index, prefixed characters, etc.).\r\n\r\n#### Skills Required\r\n\r\n- Python\r\n- Linux\r\n\r\n#### Resources\r\n\r\n- [libformatstr](https://github.com/hellman/libformatstr)\r\n- [Format String Vulnerabilities](http://jbremer.org/format-string-vulnerabilities/)\r\n\r\n#### Difficulty Level\r\n\r\nLow to medium\r\n\r\n#### Potential Mentors\r\n\r\n- `ebeip90`\r\n- `Idolf`\r\n- `br0ns`\r\n\r\n### <a name=\"encoders\"></a>Shellcode Encoders\r\n\r\nCurrently, `pwntools` does not have internal support for encoding shellcode to avoid detection by filters or functions which stop on terminators (e.g. `\\0` or `\\n`).  Previously, there was a port of Metasploit's `shikata-ga-nai` encoder which was available in pwntools.\r\n\r\nPorting this encoder back into the current `pwntools`, as well as adding additional encoders for alternate architectures, would be extremely useful for exploitation.  In particular, `pwntools` currently goes to great lengths to ensure that most shellcode that is generated is NULL- and newline-free.  Adding encoders would allow use of `pwntools`-generated for the remaining shellcode, and ease the constraints on existing shellcode.\r\n\r\n\r\n#### Skills Required\r\n\r\n- Python\r\n- Assembly\r\n\r\n#### Resources\r\n\r\n- [Shellcoder's Handbook](http://www.amazon.com/The-Shellcoders-Handbook-Discovering-Exploiting/dp/047008023X)\r\n- [Metasploit: Low Level](http://www.exploit-db.com/wp-content/themes/exploit/docs/18532.pdf)\r\n- [Cascading Polymorphic XOR Encoder in Python](http://www.iodigitalsec.com/python-cascading-xor-polymorphic-shellcode-generator/)\r\n- [ALPAH3 Shellcode Encoder](https://code.google.com/p/alpha3/)\r\n- [SLAE - Custom RBIX Shellcode Encoder](https://www.rcesecurity.com/2015/01/slae-custom-rbix-shellcode-encoder-decoder/)\r\n\r\n#### Difficulty Level\r\n\r\nMedium (port old encoder to current `pwntools`) to High (porting other encoders)\r\n\r\n#### Potential Mentors\r\n\r\n- `ebeip90`\r\n- `Idolf`\r\n- `br0ns`\r\n\r\n### <a name=\"ROP\"></a>Multi-arch support for `pwnlib.rop`\r\n\r\n#### Description\r\n\r\nCurrently, the ROP generation in the *released* version of `pwntools` does not support any architectures for automatic ROP gadget extraction, or chain building, except for on i386.\r\n\r\nGiven the increasing prevalence of x86_64, ARM, and Windows binaries, the current `pwnlib.rop` module needs to be overhauled.  In  particular, it needs support for specifying which ABI is being used, in addition to which architecture.  This is important for distinguishing x86_64 Linux vs. Windows, which use different registers to pass their arguments, as well as different stack alignments and reserved per-frame stack space.\r\n\r\nAdditionally, specification of ABIs should allow direct invokation of syscalls after properly preparing the register arguments.  While this is no different from the standard user-mode ABI on some architectures (e.g. x86_64 Linux), it differs greatly on others (i386 Linux).\r\n\r\n#### Skills Required\r\n\r\n- Python\r\n- Linux\r\n- Assembly\r\n- Familiar with buffer overflows \r\n\r\n#### Resources\r\n\r\n- [Return Oriented Programming (PSU.edu)](http://www.cse.psu.edu/~tjaeger/cse443-s12/slides/cse443-lecture-25-rop.pdf)\r\n\r\n#### Difficulty Level\r\n\r\nHigh, but varies depending on familiarity with the underlying technique of Return\r\n\r\n#### Potential Mentors\r\n\r\n- `ebeip90`\r\n- `Idolf`\r\n- `br0ns`\r\n\r\n","google":"UA-1685543-11","note":"Don't delete this file! It's used internally to help with page regeneration."}